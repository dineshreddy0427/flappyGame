<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PUBG Mini — Target Range</title>
<style>
  :root{ --bg:#0f1724; --panel:#0b1220; --accent:#18a0fb; --muted:#aab6c6; --danger:#ff6b6b; }
  html,body{height:100%;margin:0;background:linear-gradient(180deg,#071021,#0f1724);color:#e6f0f6;font-family:Inter,system-ui,Arial;}
  .wrap{max-width:1100px;margin:18px auto;padding:12px;display:flex;flex-direction:column;gap:12px}
  header{display:flex;align-items:center;justify-content:space-between}
  h1{margin:0;font-size:20px;color:var(--accent)}
  .controls{display:flex;gap:10px;align-items:center}
  .btn{background:transparent;border:1px solid rgba(255,255,255,0.05);padding:8px 10px;border-radius:8px;color:var(--muted);cursor:pointer}
  .panel{background:linear-gradient(180deg,rgba(255,255,255,0.02),transparent);padding:10px;border-radius:10px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
  #gameWrap{display:flex;gap:12px;align-items:flex-start}
  canvas{border-radius:10px;background:linear-gradient(180deg,#08202e,#061421);box-shadow:0 12px 40px rgba(2,6,23,0.7);flex:1}
  .side{width:280px;display:flex;flex-direction:column;gap:10px}
  .stat{font-size:14px;color:var(--muted)}
  .big{font-size:22px;color:#fff;font-weight:700}
  .hint{font-size:13px;color:var(--muted)}
  .small{font-size:12px;color:var(--muted)}
  .weapon{display:flex;gap:6px;align-items:center}
  .progress{height:10px;background:rgba(255,255,255,0.04);border-radius:6px;overflow:hidden}
  .progress > i{display:block;height:100%;background:linear-gradient(90deg,var(--accent),#6ef);width:0%}
  footer{display:flex;justify-content:space-between;align-items:center;color:var(--muted);font-size:13px}
  .touchRow{display:none;gap:6px;justify-content:center}
  .touchRow button{padding:10px;border-radius:10px;border:0;background:rgba(255,255,255,0.03);color:var(--muted)}
  @media (max-width:900px){
    .wrap{padding:8px}
    .side{width:100%}
    #gameWrap{flex-direction:column}
    .touchRow{display:flex}
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>PUBG Mini — Target Range</h1>
        <div class="hint">Aim, shoot, and score points — practice your accuracy!</div>
      </div>
      <div class="controls">
        <button id="startBtn" class="btn">Start Round</button>
        <button id="resetBest" class="btn">Reset Best</button>
      </div>
    </header>

    <div id="gameWrap">
      <canvas id="gameCanvas" width="900" height="520"></canvas>

      <div class="side panel">
        <div class="stat">Time Left: <span id="timeLeft" class="big">60</span>s</div>
        <div class="stat">Score: <span id="score" class="big">0</span></div>
        <div class="stat">Best: <span id="best" class="big">0</span></div>

        <div style="margin-top:6px">
          <div class="small">Weapon</div>
          <div class="weapon">
            <button id="weapon1" class="btn">1: Pistol</button>
            <button id="weapon2" class="btn">2: Rifle</button>
          </div>
          <div style="margin-top:6px" class="small">Ammo: <span id="ammo">—</span> · Reload: <strong>R</strong></div>
          <div style="margin-top:6px">
            <div class="small">Reload progress</div>
            <div class="progress" style="margin-top:6px"><i id="reloadBar"></i></div>
          </div>
        </div>

        <div style="margin-top:10px">
          <div class="small">Round settings</div>
          <div style="display:flex;gap:8px;margin-top:6px">
            <label class="small">Duration <input type="number" id="roundDur" value="60" style="width:70px"/></label>
            <label class="small">Difficulty <select id="difficulty"><option value="1">Easy</option><option value="2" selected>Normal</option><option value="3">Hard</option></select></label>
          </div>
        </div>

        <div style="margin-top:10px">
          <div class="small">Stats</div>
          <div class="small">Shots: <span id="shots">0</span></div>
          <div class="small">Hits: <span id="hits">0</span></div>
          <div class="small">Accuracy: <span id="acc">0%</span></div>
          <div class="small">Headshots: <span id="heads">0</span></div>
        </div>

        <div style="margin-top:10px">
          <div class="small">Controls</div>
          <div class="small">Aim: Mouse / Touch · Shoot: Click / Tap · Reload: R · Switch: 1 / 2</div>
        </div>

        <div class="panel" style="margin-top:10px">
          <div class="small">Tips</div>
          <ul class="small" style="margin:6px 0 0 18px">
            <li>Headshots give ×2 points</li>
            <li>Rifle deals more damage but has limited ammo</li>
            <li>Finish the round within time to record score</li>
          </ul>
        </div>

        <div class="touchRow" style="margin-top:10px">
          <button id="touchLeft">◀</button>
          <button id="touchShoot">Shoot</button>
          <button id="touchRight">▶</button>
        </div>
      </div>
    </div>

    <footer>
      <div class="small">Made with ❤️ — Practice to improve your aim</div>
      <div class="small">Version 1.0</div>
    </footer>
  </div>

<script>
/* PUBG Mini — Target Range
   Single file HTML5 game
*/

// Canvas setup
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
let W = canvas.width, H = canvas.height;
function resize() {
  const ratio = devicePixelRatio || 1;
  const rect = canvas.getBoundingClientRect();
  W = rect.width; H = rect.height;
  canvas.width = Math.floor(W * ratio); canvas.height = Math.floor(H * ratio);
  ctx.setTransform(ratio,0,0,ratio,0,0);
}
window.addEventListener('resize', resize);
resize();

// Game state
let running = false;
let roundTime = 60; // seconds
let difficulty = 2; // 1 easy,2 normal,3 hard
let timeLeft = roundTime;
let score = 0;
let best = parseInt(localStorage.getItem('pubg_mini_best') || '0', 10);
let shots = 0, hits = 0, headshots = 0;
let bullets = []; // visual bullets
let targets = [];
let spawnTimer = 0;
let spawnInterval = 1000; // ms
let lastTs = 0;

// DOM
const startBtn = document.getElementById('startBtn');
const resetBest = document.getElementById('resetBest');
const timeLeftEl = document.getElementById('timeLeft');
const scoreEl = document.getElementById('score');
const bestEl = document.getElementById('best');
const shotsEl = document.getElementById('shots');
const hitsEl = document.getElementById('hits');
const accEl = document.getElementById('acc');
const headsEl = document.getElementById('heads');
const ammoEl = document.getElementById('ammo');
const reloadBar = document.getElementById('reloadBar');
const roundDur = document.getElementById('roundDur');
const difficultyEl = document.getElementById('difficulty');

// weapons
const weapons = {
  pistol: { name:'Pistol', mag:15, reloadMs:900, damage:1, fireRate:220, headMultiplier:1.5 },
  rifle:  { name:'Rifle', mag:8, reloadMs:1400, damage:2, fireRate:120, headMultiplier:2.0 }
};
let currentWeapon = 'rifle';
let ammo = weapons[currentWeapon].mag;
let lastShotTime = 0;
let reloading = false;
let reloadProgress = 0;

// audio (tiny beeps)
const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
function sfx(freq=800, t=0.06, type='sine', vol=0.06) {
  try {
    const o = audioCtx.createOscillator();
    const g = audioCtx.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g); g.connect(audioCtx.destination);
    o.start();
    g.gain.exponentialRampToValueAtTime(0.0001, audioCtx.currentTime + t);
    setTimeout(()=>{ o.stop(); }, t*1000 + 60);
  } catch(e){}
}

// helper
function rand(min,max){ return Math.random()*(max-min)+min; }
function clamp(v,a,b){ return Math.max(a,Math.min(b,v)); }

// targets: each target has x,y,w,h,type (stationary/moving),hp
function spawnTarget() {
  const ttype = Math.random() < 0.5 ? 'stationary' : 'moving';
  const w = rand(36, 68);
  const h = w * 0.9;
  const x = rand(60, W-60);
  const y = rand(60, H*0.6);
  const speed = (ttype === 'moving') ? rand(30 + difficulty*20, 90 + difficulty*30) : 0;
  const dir = Math.random() < 0.5 ? -1 : 1;
  const hp = (difficulty === 3) ? 2 : 1;
  const color = ['#e74c3c','#f1c40f','#1abc9c'][Math.floor(Math.random()*3)];
  targets.push({ x,y,w,h,ttype,speed,dir,hp,color,ang:0 });
}

// draw target with head area
function drawTarget(t) {
  ctx.save();
  ctx.translate(t.x, t.y);
  if(t.ttype === 'moving') t.ang += 0.02 * t.dir;
  // body
  ctx.fillStyle = t.color;
  ctx.beginPath();
  ctx.ellipse(0, 0, t.w/2, t.h/2, t.ang, 0, Math.PI*2);
  ctx.fill();
  // head (upper circle) - smaller
  ctx.fillStyle = '#fff';
  ctx.beginPath();
  ctx.ellipse(0, -t.h*0.25, t.w*0.22, t.h*0.22, 0, 0, Math.PI*2);
  ctx.fill();
  // outline
  ctx.lineWidth = 2;
  ctx.strokeStyle = 'rgba(0,0,0,0.35)';
  ctx.stroke();
  ctx.restore();
}

// hit test: returns 'head'|'body'|null
function targetHitTest(t, px, py) {
  // local coordinates
  const lx = px - t.x;
  const ly = py - t.y;
  // head
  const hx = 0, hy = -t.h*0.25;
  const headRx = t.w*0.22, headRy = t.h*0.22;
  if(((lx-hx)**2)/(headRx*headRx) + ((ly-hy)**2)/(headRy*headRy) <= 1) return 'head';
  // body ellipse
  const bodyRx = t.w/2, bodyRy = t.h/2;
  if((lx*lx)/(bodyRx*bodyRx) + (ly*ly)/(bodyRy*bodyRy) <= 1) return 'body';
  return null;
}

// shooting
let aimX = W/2, aimY = H/2;
canvas.addEventListener('mousemove', e => {
  const r = canvas.getBoundingClientRect();
  aimX = e.clientX - r.left;
  aimY = e.clientY - r.top;
});
canvas.addEventListener('touchmove', e => {
  const t0 = e.touches[0];
  const r = canvas.getBoundingClientRect();
  aimX = t0.clientX - r.left; aimY = t0.clientY - r.top;
  e.preventDefault();
},{passive:false});

function shootAt(x,y) {
  const now = performance.now();
  const weapon = weapons[currentWeapon];
  if(reloading) return;
  if(now - lastShotTime < weapon.fireRate) return;
  if(ammo <= 0) { sfx(180,0.08,'sawtooth',0.08); startReload(); return; }

  lastShotTime = now;
  ammo--; shots++; sfx(1200,0.06,'square',0.06);
  bullets.push({x:W/2, y:H-20, tx:x, ty:y, life: 700}); // visual tracer

  // check hits (prioritize nearest target)
  let hit = false;
  for(let i=targets.length-1;i>=0;i--){
    const t = targets[i];
    const res = targetHitTest(t, x, y);
    if(res) {
      hit = true; hits++;
      // score calc
      let add = 10 * weapon.damage;
      let isHead = res === 'head';
      if(isHead) { add = Math.round(add * weapon.headMultiplier); headshots++; sfx(2000,0.09,'sine',0.08); }
      score += add;
      t.hp -= weapon.damage;
      if(t.hp <= 0) {
        targets.splice(i,1);
        // small explosion points
        for(let k=0;k<6;k++) bullets.push({x:t.x, y:t.y, tx:t.x+rand(-40,40), ty:t.y+rand(-40,40), life:400});
        sfx(300 + Math.random()*600, 0.12, 'sawtooth', 0.08);
      } else {
        sfx(800,0.06,'sine',0.05);
      }
      break; // one shot only
    }
  }
  if(!hit) sfx(300,0.04,'triangle',0.04);
  updateUI();
}

// UI updates
function updateUI() {
  timeLeftEl.textContent = Math.max(0, Math.ceil(timeLeft));
  scoreEl.textContent = score;
  bestEl.textContent = best;
  shotsEl.textContent = shots;
  hitsEl.textContent = hits;
  accEl.textContent = shots ? Math.round(hits / shots * 100) + '%' : '0%';
  headsEl.textContent = headshots;
  ammoEl.textContent = ammo + ' / ' + weapons[currentWeapon].mag;
  reloadBar.style.width = (reloading ? (reloadProgress*100) + '%' : '0%');
}

// input handlers
canvas.addEventListener('click', e => {
  const r = canvas.getBoundingClientRect();
  const x = e.clientX - r.left, y = e.clientY - r.top;
  shootAt(x,y);
});
canvas.addEventListener('touchstart', e => {
  const t0 = e.touches[0];
  const r = canvas.getBoundingClientRect();
  const x = t0.clientX - r.left, y = t0.clientY - r.top;
  shootAt(x,y); e.preventDefault();
},{passive:false});

// keyboard
window.addEventListener('keydown', e => {
  if(e.key === 'r' || e.key === 'R') { startReload(); }
  if(e.key === '1') { selectWeapon('pistol'); }
  if(e.key === '2') { selectWeapon('rifle'); }
});

document.getElementById('touchShoot').addEventListener('touchstart', e => { const r = canvas.getBoundingClientRect(); shootAt(aimX, aimY); e.preventDefault(); });
document.getElementById('touchLeft').addEventListener('touchstart', e => { aimX = clamp(aimX - 60, 0, W); e.preventDefault(); });
document.getElementById('touchRight').addEventListener('touchstart', e => { aimX = clamp(aimX + 60, 0, W); e.preventDefault(); });

// weapon select
function selectWeapon(name) {
  currentWeapon = name;
  ammo = weapons[currentWeapon].mag;
  reloading = false; reloadProgress = 0;
  updateUI();
  sfx(600,0.04,'sine',0.04);
}
document.getElementById('weapon1').addEventListener('click', ()=> selectWeapon('pistol'));
document.getElementById('weapon2').addEventListener('click', ()=> selectWeapon('rifle'));

// reload
function startReload() {
  if(reloading) return;
  reloading = true;
  reloadProgress = 0;
  const ms = weapons[currentWeapon].reloadMs;
  const start = performance.now();
  const tick = () => {
    const elapsed = performance.now() - start;
    reloadProgress = clamp(elapsed / ms, 0, 1);
    reloadBar.style.width = (reloadProgress*100)+'%';
    if(reloadProgress < 1) requestAnimationFrame(tick);
    else {
      reloading = false;
      ammo = weapons[currentWeapon].mag;
      reloadProgress = 0;
      updateUI();
      sfx(800,0.07,'sine',0.05);
    }
  };
  requestAnimationFrame(tick);
}

// game loop
function update(dt) {
  if(!running) return;
  spawnTimer += dt*1000;
  // difficulty affects spawn rate
  const baseInterval = 900 - (difficulty-1)*220;
  if(spawnTimer > baseInterval) {
    spawnTimer = 0;
    spawnTarget();
    // maybe spawn extra on higher difficulty
    if(Math.random() < 0.25 * difficulty) spawnTarget();
  }

  // move targets
  for(const t of targets) {
    if(t.ttype === 'moving') {
      t.x += t.speed * t.dir * dt;
      // bounce
      if(t.x < 40) t.dir = 1;
      if(t.x > W-40) t.dir = -1;
    }
  }

  // bullets visual life
  for(let i=bullets.length-1;i>=0;i--){
    bullets[i].life -= dt*1000;
    if(bullets[i].life <= 0) bullets.splice(i,1);
  }
}

function draw() {
  // clear
  ctx.clearRect(0,0,W,H);
  // background grid
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  for(let i=0;i<W;i+=40){
    ctx.fillRect(i,0,1,1);
  }
  // draw targets
  for(const t of targets) drawTarget(t);
  // draw aim cursor
  ctx.beginPath();
  ctx.strokeStyle = 'rgba(255,255,255,0.9)';
  ctx.lineWidth = 2;
  ctx.arc(aimX, aimY, 14, 0, Math.PI*2);
  ctx.stroke();
  ctx.beginPath();
  ctx.moveTo(aimX-22, aimY); ctx.lineTo(aimX-8, aimY);
  ctx.moveTo(aimX+22, aimY); ctx.lineTo(aimX+8, aimY);
  ctx.moveTo(aimX, aimY-22); ctx.lineTo(aimX, aimY-8);
  ctx.moveTo(aimX, aimY+22); ctx.lineTo(aimX, aimY+8);
  ctx.stroke();

  // bullets / tracers
  for(const b of bullets) {
    ctx.beginPath();
    const t = (b.life/700);
    const x = b.tx + (b.x - b.tx) * t;
    const y = b.ty + (b.y - b.ty) * t;
    ctx.strokeStyle = 'rgba(255,230,160,0.9)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(W/2, H-20);
    ctx.lineTo(b.tx, b.ty);
    ctx.stroke();
  }

  // HUD: crosshair info
  ctx.fillStyle = 'rgba(255,255,255,0.02)';
  ctx.fillRect(10, H-60, 260, 46);
  ctx.fillStyle = '#fff';
  ctx.font = '14px system-ui, Arial';
  ctx.fillText(`${weapons[currentWeapon].name} · Ammo: ${ammo}/${weapons[currentWeapon].mag}`, 18, H-36);
  ctx.fillText(`Shots ${shots} · Hits ${hits} · HS ${headshots}`, 18, H-18);

  // overlays
  if(!running) {
    ctx.fillStyle = 'rgba(0,0,0,0.45)';
    ctx.fillRect(0,0,W,H);
    ctx.fillStyle = '#fff';
    ctx.font = '28px system-ui, Arial';
    ctx.textAlign = 'center';
    ctx.fillText('Press "Start Round" to play', W/2, H/2 - 10);
    ctx.font = '14px system-ui, Arial';
    ctx.fillText('Controls: Aim with mouse/touch, Click/tap to shoot, R to reload, 1/2 to switch weapons', W/2, H/2 + 16);
    ctx.textAlign = 'start';
  }
}

function loop(ts) {
  if(!lastTs) lastTs = ts;
  const dt = Math.min(0.05, (ts - lastTs)/1000);
  lastTs = ts;
  if(running) {
    update(dt);
    // countdown
    timeLeft -= dt;
    if(timeLeft <= 0) {
      endRound();
    }
  }
  draw();
  updateUI();
  requestAnimationFrame(loop);
}
requestAnimationFrame(loop);

// round control
startBtn.addEventListener('click', ()=> {
  if(!running) startRound();
  else endRound();
});
resetBest.addEventListener('click', ()=> {
  localStorage.removeItem('pubg_mini_best'); best = 0; updateUI();
});

// start/end
function startRound() {
  // warm audio
  if(audioCtx.state === 'suspended') audioCtx.resume();
  roundTime = parseFloat(roundDur.value) || 60;
  difficulty = parseInt(difficultyEl.value,10) || 2;
  timeLeft = roundTime;
  score = 0; shots = 0; hits = 0; headshots = 0;
  targets = []; bullets = [];
  ammo = weapons[currentWeapon].mag;
  running = true;
  startBtn.textContent = 'End Round';
  spawnTimer = 0;
  // spawn initial targets
  for(let i=0;i<3 + difficulty;i++) spawnTarget();
  sfx(900,0.08,'sine',0.06);
}
function endRound() {
  running = false;
  startBtn.textContent = 'Start Round';
  // save best
  if(score > best) { best = score; localStorage.setItem('pubg_mini_best', String(best)); sfx(1400,0.12,'sine',0.08); alert('New best: ' + best); }
  else alert('Round finished. Score: ' + score);
}

// update UI initial
updateUI();

// make sure canvas resizes to container
(function autoResizeCanvas() {
  const parent = canvas.parentElement;
  function fit() {
    const w = parent.clientWidth - 300 - 12; // side width accounted
    if(window.innerWidth < 900) {
      canvas.style.width = '100%';
      canvas.style.height = (window.innerWidth * 0.55) + 'px';
    } else {
      canvas.style.width = (w>500? w : 500) + 'px';
      canvas.style.height = '520px';
    }
    resize();
  }
  window.addEventListener('resize', fit);
  fit();
})();

</script>
</body>
</html>
